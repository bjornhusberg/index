#!/usr/bin/ruby

require "set"
require "digest/md5"

module IndexStatus
  UNKNOWN = 0 # Unknown status
  CHECKED = 1 # Verified file
  MISSING = 2 # Removed file
  ALTERED = 3 # Modified file
  INDEXED = 4 # New file
  RENAMED = 5 # Moved file
  DELETED = 6 # Marked for removal from index
end

class FileData
  attr_accessor :size, :checksum, :status, :oldSize, :oldChecksum, :oldFile
  def initialize(*args)
    @size, @checksum, @status = *args
  end
end

def checksum(file)
  Digest::MD5.file(file).to_s
end

def size(file)
  File.size(file).to_s
end

def parseIndex(file)
  index = Hash.new
  if File.exists? file
    File.open(file, "r:UTF-8").each do |line|
      if !/^(.*) (\d+) ([abcdef\d]+)$/.match(line)
        STDERR.puts "Index file is corrupt on line: " + line
        exit
      end
      index[$1] = FileData.new($2, $3, IndexStatus::UNKNOWN)
    end
  end
  index
end

def findFiles(directory)
  files = Array.new
  Dir.foreach(directory)
  .select{|filename| !filename.match(/^\.$/) && !filename.match(/^\..*/) && !filename.match(/^index\.txt.*/)}
  .each do |filename|
    filename = filename.encode!('UTF-8','UTF8-MAC')
    file = File.join(directory, filename)
    if File.directory?(file)
      files = files.concat(findFiles(file))
    else
      files.push(file)
    end
  end
  files
end

def indexCurrentDirectory(index)
  findFiles(".")
  .select{|file| index[file] == nil}
  .each{|file| index[file] = FileData.new(size(file), checksum(file), IndexStatus::INDEXED)}
end

def indexMissingFiles(index)
  index
  .select{|file, data| data.status == IndexStatus::UNKNOWN && !File.exists?(file)}
  .each{|file, data| data.status = IndexStatus::MISSING}
end

def indexRenamedFiles(index)
  checksums = Hash.new
  index
  .select{|file, data| data.status == IndexStatus::INDEXED}
  .each do |file, data|
    files = checksums[data.checksum]
    if files == nil
      files = Array.new
      checksums[data.checksum] = files
    end
    files.push(file)
  end
  index
  .select{|file, data| data.status == IndexStatus::MISSING}
  .each do |file, data|
    files = checksums[data.checksum]
    next if files == nil
    files.each do |otherfile|
      otherdata = index[otherfile]
      next if otherdata.size != data.size
      next if otherdata.status != IndexStatus::INDEXED
      STDERR.puts "Moved #{file} to #{otherfile}"
      data.status = IndexStatus::DELETED
      otherdata.status = IndexStatus::RENAMED
      otherdata.oldFile = file
      break
    end
  end
  index.delete_if{|file, data| data.status == IndexStatus::DELETED}
end

def verifyIndex(index, fast)
  index
  .select{|file, data| data.status == IndexStatus::UNKNOWN}
  .each do |file, data|
    size = size(file)
    checksum = fast ? data.checksum : checksum(file)
    if size != data.size || checksum != data.checksum
      checksum = fast ? checksum(file) : checksum
      data.status = IndexStatus::ALTERED
      data.oldSize = data.size
      data.oldChecksum = data.checksum
      data.size = size
      data.checksum = checksum
    else
      data.status = IndexStatus::CHECKED
    end
  end
end

def writeFile(filename, lines, skipIfEmpty=true)
  File.open(filename, 'w:UTF-8'){|out| out.puts(lines)} if !skipIfEmpty || !lines.empty?
end

def writeLog(index, logFile)
  writeFile("#{logFile}-deleted",
    index.select{|file, data| data.status == IndexStatus::MISSING}.keys)
  writeFile("#{logFile}-new",
    index.select{|file, data| data.status == IndexStatus::INDEXED}.keys)
  writeFile("#{logFile}-moved",
    index.select{|file, data| data.status == IndexStatus::RENAMED}
    .map{|file, data| "#{data.oldFile} to #{file}"})
  writeFile("#{logFile}-modified",
    index.select{|file, data| data.status == IndexStatus::ALTERED}
    .map{|file, data| "#{file} from #{data.oldChecksum} to #{data.checksum}"})
  writeFile("#{logFile}-backup",
    index.select{|file, data| data.status != IndexStatus::INDEXED}
    .map{|file, data| "#{data.oldFile || file} #{data.oldSize || data.size} #{data.oldChecksum || data.checksum}"})
end

def writeIndex(index, file)
  writeFile(file,
    index.select{|file, data| data.status != IndexStatus::MISSING}
    .sort
    .map{|file, data| "#{file} #{data.size} #{data.checksum}"},
    skipIfEmpty: false)
end

def formatFileSize(size)
  for prefix in ['', 'k', 'M', 'G', 'T']
    if size > 1024 && prefix != 'T'
      size = size / 1024
    else
      return "#{size}#{prefix}B"
    end
  end
end

def index(indexFile, fast, dry)
  index = parseIndex(indexFile)
  STDERR.puts "Index contains #{index.length} files"
  STDERR.puts "Running #{fast ? 'file size' : 'full'} index verification..."
  indexCurrentDirectory(index)
  indexMissingFiles(index)
  indexRenamedFiles(index)
  verifyIndex(index, fast)
  if index.any?{|file, data| data.status != IndexStatus::CHECKED}
    STDERR.puts "Update summary:"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::INDEXED}} new files"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::RENAMED}} renamed files"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::MISSING}} missing files"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::ALTERED}} altered files"
    if !dry
      writeLog(index, indexFile + "." + Time.now.strftime("%Y%m%d_%H%M%S"))
      writeIndex(index, indexFile)
      STDERR.puts "Index updated"
    end
  else
    STDERR.puts "Index not modified"
  end
end

def find(indexFile)
  STDERR.puts "Finding unindexed files"
  index = parseIndex(indexFile)
  STDERR.puts "Index contains #{index.length} files"
  STDERR.puts "Indexing current directory..."
  newIndex = Hash.new
  indexCurrentDirectory(newIndex)
  newFiles = newIndex.select{|file, data| index.all?{ |indexFile, indexData| data.checksum != indexData.checksum || data.length != indexData.length }}
  newFiles.each{|file, data| STDOUT.puts(file)}
  STDERR.puts "Found #{newFiles.count} unindexed files"
end

def dedup(indexFile)
  STDERR.puts "Finding duplicated files in the index"
  duplicates = parseIndex(indexFile)
  .group_by{|file, data| data.size + "-" + data.checksum}
  .select{|key, files| files.count > 1}
  duplicates.each do |key, files|
    STDERR.puts "Duplicates of #{files.first[0]}:"
    STDOUT.puts(files.drop(1).map{|file, data| file})
  end
  count = duplicates.sum{|key, files| files.length - 1}
  bytes = duplicates.sum{|key, files| (files.length - 1) * files.first[1].size.to_i}
  if count > 0
    STDERR.puts "Deduplication of #{count} files would save #{formatFileSize bytes}."
  else
    STDERR.puts "No duplicate files found"
  end
  STDERR.puts "Done."
end

fast = ARGV.delete('fast')
find = ARGV.delete('find')
dedup = ARGV.delete('dedup')
dry = ARGV.delete('dry')

if ARGV.count > 1
  STDERR.puts "Usage: index [dedup|find] [fast] [dry] [index file path]"
  return
elsif ARGV.any? && !File.exists?(ARGV.first)
  STDERR.puts "Index file not found: #{ARGV.first}"
  return
end

indexFile = ARGV.first || "index.txt"

if dedup
  dedup(indexFile)
elsif find
  find(indexFile)
else
  index(indexFile, fast, dry)
end
