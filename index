#!/usr/bin/ruby

require "set"
require "digest/md5"

module IndexStatus
  UNKNOWN = 0 # Unknown status
  CHECKED = 1 # Verified file
  MISSING = 2 # Removed file
  ALTERED = 3 # Modified file
  INDEXED = 4 # New file
  RENAMED = 5 # Moved file
  DELETED = 6 # Marked for removal from index
end

class FileData
  attr_accessor :length, :checksum, :status, :oldLength, :oldChecksum, :oldFile
  def initialize(*args)
    @length, @checksum, @status = *args
  end
end

def checksum(file)
  Digest::MD5.file(file).to_s
end

def length(file)
  File.size(file).to_s
end

def parseIndex(file)
  index = Hash.new
  if File.exists? file
    File.open(file, "r:UTF-8").each do |line|
      if !/^(.*) (\d+) ([abcdef\d]+)$/.match(line)
        STDERR.puts "Index file is corrupt on line: " + line
        exit
      end
      index[$1] = FileData.new($2, $3, IndexStatus::UNKNOWN)
    end
  end
  index
end

def findFiles(directory)
  files = Array.new
  Dir.foreach(directory)
  .select{|filename| !filename.match(/^\.$/) && !filename.match(/^\..*/) && !filename.match(/^index\.txt.*/)}
  .each do |filename|
    filename = filename.encode!('UTF-8','UTF8-MAC')
    file = File.join(directory, filename)
    if File.directory? file
      files = files.concat(findFiles(file))
    else
      files.push(file)
    end
  end
  files
end

def indexCurrentDirectory(index)
  findFiles(".")
  .select{|file| index[file] == nil}
  .each{|file| index[file] = FileData.new(length(file), checksum(file), IndexStatus::INDEXED)}
end

def indexMissingFiles(index)
  index
  .select{|file, data| data.status == IndexStatus::UNKNOWN && !File.exists?(file)}
  .each{|file, data| data.status = IndexStatus::MISSING}
end

def indexRenamedFiles(index)
  checksums = Hash.new
  index
  .select{|file, data| data.status == IndexStatus::INDEXED}
  .each do |file, data|
    files = checksums[data.checksum]
    if files == nil
      files = Array.new
      checksums[data.checksum] = files
    end
    files.push(file)
  end
  index
  .select{|file, data| data.status == IndexStatus::MISSING}
  .each do |file, data|
    files = checksums[data.checksum]
    next if files == nil
    files.each do |otherfile|
      otherdata = index[otherfile]
      next if otherdata.length != data.length
      next if otherdata.status != IndexStatus::INDEXED
      STDERR.puts "Moved #{file} to #{otherfile}"
      data.status = IndexStatus::DELETED
      otherdata.status = IndexStatus::RENAMED
      otherdata.oldFile = file
      break
    end
  end
  index.delete_if{|file, data| data.status == IndexStatus::DELETED}
end

def verifyIndex(index, fast)
  index
  .select{|file, data| data.status == IndexStatus::UNKNOWN}
  .each do |file, data|
    length = length(file)
    checksum = fast ? data.checksum : checksum(file)
    if length != data.length || checksum != data.checksum
      checksum = fast ? checksum(file) : checksum
      data.status = IndexStatus::ALTERED
      data.oldLength = data.length
      data.oldChecksum = data.checksum
      data.length = length
      data.checksum = checksum
    else
      data.status = IndexStatus::CHECKED
    end
  end
end

def writeLog(index, logFile)
  files = index.select{|file,data| data.status == IndexStatus::MISSING}
  if !files.empty?
    out = File.open(logFile + "-deleted", 'w')
    files.each do |file,data|
      out.puts file
    end
  end
  files = index.select{|file,data| data.status == IndexStatus::INDEXED}
  if !files.empty?
    out = File.open(logFile + "-new", 'w')
    files.each do |file,data|
      out.puts file
    end
  end
  files = index.select{|file,data| data.status == IndexStatus::RENAMED}
  if !files.empty?
    out = File.open(logFile + "-moved", 'w')
    files.each do |file,data|
      out.puts "#{data.oldFile} to #{file}"
    end
  end
  files = index.select{|file,data| data.status == IndexStatus::ALTERED}
  if !files.empty?
    out = File.open(logFile + "-modified", 'w')
    files.each do |file,data|
      out.puts "#{file} from #{data.oldChecksum} to #{data.checksum}"
    end
  end
  out = File.open(logFile + "-backup", 'w')
  files = index.select{|file,data| data.status != IndexStatus::INDEXED}
  files.each do |file,data|
    out.puts "#{data.oldFile || file} #{data.oldLength || data.length} #{data.oldChecksum || data.checksum}"
  end
end

def writeIndex(index, file)
  out = File.open(file, 'w:UTF-8')
  index.keys.sort.each do |f|
    data = index[f]
    next if data.status == IndexStatus::MISSING
    out.puts "#{f} #{data.length} #{data.checksum}"
  end
end

def index(indexFile, fast)
  index = parseIndex(indexFile)
  STDERR.puts "Index contains #{index.length} files"
  STDERR.puts "Running #{fast ? 'file size' : 'full'} index verification..."
  indexCurrentDirectory(index)
  indexMissingFiles(index)
  indexRenamedFiles(index)
  verifyIndex(index, fast)
  if index.any?{|f,data| data.status != IndexStatus::CHECKED}
    STDERR.puts "Update summary:"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::INDEXED}} new files"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::RENAMED}} renamed files"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::MISSING}} missing files"
    STDERR.puts "#{index.count{|file, data| data.status == IndexStatus::ALTERED}} altered files"
    writeLog(index, indexFile + "." + Time.now.strftime("%Y%m%d_%H%M%S"))
    writeIndex(index, indexFile)
    STDERR.puts "Index updated"
  else
    STDERR.puts "Index not modified"
  end
end

def find(indexFile)
  STDERR.puts "Finding unindexed files"
  index = parseIndex(indexFile)
  STDERR.puts "Index contains #{index.length} files"
  STDERR.puts "Indexing current directory..."
  newIndex = Hash.new
  indexCurrentDirectory(newIndex)
  newFiles = newIndex.select{ |file, data| ! index.any?{ |indexFile, indexData| data.checksum == indexData.checksum && data.length == indexData.length }}
  STDERR.puts "Found #{newFiles.count} unindexed files"
  newFiles.each do |file, data|
    STDOUT.puts file
  end
end

def formatFileSize(size)
  for prefix in ['', 'k', 'M', 'G', 'T']
    if size > 1024 && prefix != 'T'
      size = size / 1024
    else
      return "#{size}#{prefix}B"
    end
  end
end

def dedup(indexFile)
  STDERR.puts "Finding duplicated files in the index"
  index = parseIndex(indexFile)
  groups = index.group_by{ |file, data| data.length + "-" + data.checksum }
  duplicates = groups.select{ |key, files| files.count > 1 }
  bytes = 0
  count = 0
  duplicates.each do |key, files|
    STDERR.puts "Duplicates of #{files.first[0]}:"
    files.drop(1).each do |file, data|
      STDOUT.puts file
      bytes += data.length.to_i
      count += 1
    end
  end
  if count > 0
    STDERR.puts "Deduplication of #{count} files would save #{formatFileSize bytes}."
  else
    STDERR.puts "No duplicate files found"
  end
  STDERR.puts "Done."
end

fast = ARGV.any? { |arg| arg == 'fast' }
find = ARGV.any? { |arg| arg == 'find' }
dedup = ARGV.any? { |arg| arg == 'dedup' }

indexFile = ARGV.find { |arg| arg != 'fast' && arg != 'find' && arg != 'dedup' }
indexFile = indexFile ? indexFile : "index.txt"

if dedup
  dedup(indexFile)
elsif find
  find(indexFile)
else
  index(indexFile, fast)
end
