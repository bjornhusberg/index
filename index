#!/usr/bin/ruby

require "set"
require "digest/md5"

module IndexStatus
  UNKNOWN = 0 # Unknown status
  CHECKED = 1 # Verified file
  MISSING = 2 # Removed file
  ALTERED = 3 # Modified file
  INDEXED = 4 # New file
  RENAMED = 5 # Moved file
  DELETED = 6 # Marked for removal from index
end

class FileData
  attr_accessor :size, :checksum, :status, :oldSize, :oldChecksum, :oldFile
  def initialize(*args)
    @size, @checksum, @status = *args
  end
end

$default_index_filename = "index.txt"

def checksum(file)
  Digest::MD5.file(file).to_s
end

def size(file)
  File.size(file).to_s
end

def parseIndex(file)
  index = Hash.new
  if File.exists? file
    File.open(file, "r:UTF-8").each do |line|
      if !/^(.*) (\d+) ([abcdef\d]+)$/.match(line)
        STDERR.puts "Index file is corrupt on line: " + line
        exit
      end
      index[$1] = FileData.new($2, $3, IndexStatus::UNKNOWN)
    end
  end
  index
end

def filterIndex(index, status)
  index.select{|file, data| data.status == status}
end

def findFiles(directory)
  files = Array.new
  Dir.foreach(directory)
  .select{|filename| !filename.match(/^\.$/) && !filename.match(/^\..*/) && !filename.match(/^index\.txt.*/)}
  .each do |filename|
    filename = filename.encode!('UTF-8','UTF8-MAC')
    file = File.join(directory, filename)
    if File.directory?(file)
      files = files.concat(findFiles(file))
    else
      files.push(file)
    end
  end
  files
end

def indexCurrentDirectory(index)
  findFiles(".")
  .select{|file| index[file] == nil}
  .each{|file| index[file] = FileData.new(size(file), checksum(file), IndexStatus::INDEXED)}
end

def indexMissingFiles(index)
  index
  .select{|file, data| data.status == IndexStatus::UNKNOWN && !File.exists?(file)}
  .each{|file, data| data.status = IndexStatus::MISSING}
end

def indexRenamedFiles(index)
  checksums = Hash.new
  filterIndex(index, IndexStatus::INDEXED).each do |file, data|
    files = checksums[data.checksum]
    if files == nil
      files = Array.new
      checksums[data.checksum] = files
    end
    files.push(file)
  end
  filterIndex(index, IndexStatus::MISSING).each do |file, data|
    files = checksums[data.checksum]
    next if files == nil
    files.each do |otherfile|
      otherdata = index[otherfile]
      next if otherdata.size != data.size
      next if otherdata.status != IndexStatus::INDEXED
      STDERR.puts "Moved #{file} to #{otherfile}"
      data.status = IndexStatus::DELETED
      otherdata.status = IndexStatus::RENAMED
      otherdata.oldFile = file
      break
    end
  end
  index.delete_if{|file, data| data.status == IndexStatus::DELETED}
end

def verifyIndex(index, fast)
  filterIndex(index, IndexStatus::UNKNOWN).each do |file, data|
    size = size(file)
    checksum = fast ? data.checksum : checksum(file)
    if size != data.size || checksum != data.checksum
      checksum = fast ? checksum(file) : checksum
      data.status = IndexStatus::ALTERED
      data.oldSize = data.size
      data.oldChecksum = data.checksum
      data.size = size
      data.checksum = checksum
    else
      data.status = IndexStatus::CHECKED
    end
  end
end

def writeFile(filename, lines, skipIfEmpty=true)
  File.open(filename, 'w:UTF-8'){|out| out.puts(lines)} if !skipIfEmpty || !lines.empty?
end

def writeLog(index, logFile)
  writeFile("#{logFile}-deleted", filterIndex(index, IndexStatus::MISSING).keys)
  writeFile("#{logFile}-new", filterIndex(index, IndexStatus::INDEXED).keys)
  writeFile("#{logFile}-moved", filterIndex(index, IndexStatus::RENAMED)
    .map{|file, data| "#{data.oldFile} to #{file}"})
  writeFile("#{logFile}-modified", filterIndex(index, IndexStatus::ALTERED)
    .map{|file, data| "#{file} from #{data.oldChecksum} to #{data.checksum}"})
  writeFile("#{logFile}-backup", index.select{|file, data| data.status != IndexStatus::INDEXED}
    .map{|file, data| "#{data.oldFile || file} #{data.oldSize || data.size} #{data.oldChecksum || data.checksum}"})
end

def writeIndex(index, file)
  writeFile(file,
    index.select{|file, data| data.status != IndexStatus::MISSING}
    .sort
    .map{|file, data| "#{file} #{data.size} #{data.checksum}"},
    skipIfEmpty: false)
end

def formatFileSize(size)
  for prefix in ['', 'k', 'M', 'G', 'T']
    break if size < 1024
    size /= 1024
  end
  "#{size}#{prefix}B"
end

def index(indexFile, fast, dry)
  index = parseIndex(indexFile)
  STDERR.puts "Index contains #{index.length} files"
  STDERR.puts "Running #{fast ? 'file size' : 'full'} index verification..."
  indexCurrentDirectory(index)
  indexMissingFiles(index)
  indexRenamedFiles(index)
  verifyIndex(index, fast)
  if index.any?{|file, data| data.status != IndexStatus::CHECKED}
    STDERR.puts "Update summary:"
    STDERR.puts "#{filterIndex(index, IndexStatus::INDEXED).count} new files"
    STDERR.puts "#{filterIndex(index, IndexStatus::RENAMED).count} renamed files"
    STDERR.puts "#{filterIndex(index, IndexStatus::MISSING).count} missing files"
    STDERR.puts "#{filterIndex(index, IndexStatus::ALTERED).count} altered files"
    if !dry
      writeLog(index, indexFile + "." + Time.now.strftime("%Y%m%d_%H%M%S"))
      writeIndex(index, indexFile)
      STDERR.puts "Index updated"
    end
  else
    STDERR.puts "Index not modified"
  end
end

def hashkey(data)
  "#{data.size}-#{data.checksum}"
end

def find(indexFile)
  STDERR.puts "Finding unindexed files"
  remoteIndex = parseIndex(indexFile)
  keys = remoteIndex.map{|file, data| hashkey(data)}.to_set
  STDERR.puts "Remote index contains #{remoteIndex.length} files"
  localIndex = indexFile == $default_index_filename ? Hash.new : parseIndex($default_index_filename)
  STDERR.puts "Indexing current directory..."
  indexCurrentDirectory(localIndex)
  STDERR.puts "Local index contains #{localIndex.length} files"
  newFiles = localIndex.select{|file, data| !keys.include?(hashkey(data))}
  newFiles.each{|file, data| STDOUT.puts(file)}
  STDERR.puts "Found #{newFiles.count} unindexed files"
end

def dedup(indexFile)
  STDERR.puts "Finding duplicated files in the index"
  duplicates = parseIndex(indexFile)
  .group_by{|file, data| hashkey(data)}
  .select{|key, files| files.count > 1}
  .map{|key, files| files.to_h}
  if duplicates.empty?
    STDERR.puts "No duplicate files found"
    return
  end
  duplicates.each do |files|
    STDERR.puts "Duplicates of #{files.keys.first} (#{files.values.first.size} bytes):"
    STDOUT.puts(files.keys.drop(1))
  end
  count = duplicates.sum{|files| files.length - 1}
  bytes = duplicates.sum{|files| (files.length - 1) * files.values.first.size.to_i}
  STDERR.puts "Deduplication of #{count} files would save #{formatFileSize bytes}."
end

fast = ARGV.delete('fast')
find = ARGV.delete('find')
dedup = ARGV.delete('dedup')
dry = ARGV.delete('dry')

if ARGV.count > 1
  STDERR.puts "Usage: index [dedup|find] [fast] [dry] [index file path]"
  return
elsif ARGV.any? && !File.exists?(ARGV.first)
  STDERR.puts "Index file not found: #{ARGV.first}"
  return
end

indexFile = ARGV.first || $default_index_filename

if dedup
  dedup(indexFile)
elsif find
  find(indexFile)
else
  index(indexFile, fast, dry)
end
